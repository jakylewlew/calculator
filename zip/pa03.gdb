target remote :1234
set architecture arm

# load the symbol table generated by the assembler 
# (so we can reference addresses by labels)
file pa03.elf

# you can define commands that you repeat frequently
define showExecution
print "Start of execution call"
# display register values
printf "program counter: 0x%x (decimal: %d)\n", $pc, $pc
printf "link register: 0x%x (decimal: %d)\n", $lr, $lr
i r
x /1x _operandA
x /1x _operandB
x /1x _operation
cont
end

# set a breakpoint at label executeAdd (this label needs to exist
# set the label based on what you have available in your program)
# this will be called each time the label executeAdd is reached in your 
# program, and will print register values
#break *executeAdd
#commands
#showExecution
#end

#break *executeSubtract
#commands
#showExecution
#end

#b *isOperation
#commands
#showExecution
#end

#b *isNumber
#commands
#showExecution
#end

#break *executeMultiply
#commands
#showExecution
#end

#break *&executeDivide + 4
#commands
#showExecution
#step
#showExectution
#step
#showExectution
#step
#showExectution
#step
#showExectution
#step
#showExectution
#step
#showExectution
#step
#showExectution
#end

#break *executeNegate
#commands
#showExecution
#end

#break *&executeMultiply + 4
#commands
#print "BREAK AT OFFSET"
#end

break *iloop
commands
showExecution
print "At infinite loop (end of program)"
end

# set a breakpoint at label handleUndefined (this label needs to exist)
#break *handleUndefined
#commands
#print "Undefined handler called"
#i r
## show stack pointer values
#print "Stack values"
#printf "stack pointer: 0x%x (decimal: %d)\n", $sp, $sp
## look at memory address $sp (show the next 16 addresses)
#x /16x $sp
#cont
#end

# print the starting values of registers
print "starting register values:"
i r


# continue execution of your program
cont
